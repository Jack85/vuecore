<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".gen.cs" #>
<# /* Update this line to match your version of SignalR */ #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.AspNet.SignalR.Core.2.2.1\lib\net45\Microsoft.AspNet.SignalR.Core.dll" #>
<# /* Load the current project's DLL to make sure the DefaultHubManager can find things */ #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Web" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="Microsoft.AspNet.SignalR" #>
<#@ import namespace="Microsoft.AspNet.SignalR.Hubs" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    var hubmanager = new DefaultHubManager(new DefaultDependencyResolver());
#>


//GENERATED <#= DateTime.Now.ToString() #>
////////////////////
// available hubs //
////////////////////
//#region available hubs
using Microsoft.AspNet.SignalR.Client;
using System;
using System.Collections.Generic;
using SignalDomain;


public class SignalR {
public string Url{get;set;}
public string Cookie{get;set;}
public  HubConnection con{get;set;}
	public SignalR(string url, string cookie)
	{
		Url = url;
		Cookie = cookie;
		con = new HubConnection(url);
		con.Headers.Add("token", cookie);
		
		 <#
foreach (var hub in hubmanager.GetHubs())
{
#>		<#= hub.NameSpecified?hub.Name:FirstCharLowered(hub.Name) #> = new  <#= hub.HubType.Name #>Server(con);
		  <# }#>
		con.Start();
	}
<#
foreach (var hub in hubmanager.GetHubs())
{
#>

    /**
      * The hub implemented by <#=hub.HubType.FullName#>
      */
 public  <#= hub.HubType.Name #>Server <#= hub.NameSpecified?hub.Name:FirstCharLowered(hub.Name) #> ; // new  <#= hub.HubType.Name #>Server(con) ;
<#
}
#>
}
//#endregion available hubs

///////////////////////
// Service Contracts //
///////////////////////
//#region service contracts
<#
foreach (var hub in hubmanager.GetHubs())
{
    var hubType = hub.HubType;
	Type clientType = ClientType(hubType);

	
#>

//#region <#= hub.Name#> hub

//public class <#= hubType.Name #> {
    
    /**
      * This property lets you send messages to the <#= hub.Name#> hub.
      */
 //   server : <#= hubType.Name #>Server;

    /**
      * The functions on this property should be replaced if you want to receive messages from the <#= hub.Name#> hub.
      */
//    client : <#= clientType != null?clientType.Name:"any"#>;
//}

<#
/* Server type definition */
#>
public class <#= hubType.Name #>Server {
 public  IHubProxy hub { get; set; }
public <#= hubType.Name #>Server(HubConnection con)
{
hub =  con.CreateHubProxy("<#= hubType.Name #>");
}
<#
    foreach (var method in hubmanager.GetHubMethods(hub.Name ))
    {
	var names =method.Parameters.Select(x => x.Name); int c = names.Count();
	bool cx = GetTypeContractName(method.ReturnType)=="void";
        var ps = method.Parameters.Select(x => GetTypeContractName(x.ParameterType) + " " +x.Name);
        var docs = GetXmlDocForMethod(hubType.GetMethod(method.Name));

#>

    /** 
      * Sends a "<#= FirstCharLowered(method.Name) #>" message to the <#= hub.Name#> hub.
      * Contract Documentation: <#= docs.Summary #>
<#
    foreach (var p in method.Parameters)
    {
#>
      * @param <#=p.Name#> {<#=GetTypeContractName(p.ParameterType)#>} <#=docs.ParameterSummary(p.Name)#>
<#
    }
#>
      * @return {JQueryPromise of <#= GetTypeContractName(method.ReturnType)#>}
      */
   public <#= GetTypeContractName(method.ReturnType)#> <#= FirstCharLowered(method.Name) #>(<#=string.Join(", ", ps)#>) 
	{
	<#if(!cx){#>
   return  hub.Invoke<#if(!cx){#><<#}#><#= GetTypeContractName(method.ReturnType)#><#if(!cx){#>><#}#>("<#= FirstCharLowered(method.Name)+"" #>" <#if(c>0){#> , <#}#><#=string.Join(", ", names)#>).Result;
		<#}else{#>
 hub.Invoke("<#= FirstCharLowered(method.Name)+"" #>" <#if(c>0){#> , <#}#><#=string.Join(", ", names)#>);return;
	<#}#>
}
<#}#>
}

<#
/* Client type definition */
#>
<# 
    if (clientType != null)
    {
#>
class <#= clientType.Name #>
{
<#
    foreach (var method in clientType.GetMethods())
    {
        var ps = method.GetParameters().Select(x =>GetTypeContractName(x.ParameterType) +" "+ x.Name);
        var docs = GetXmlDocForMethod(method);

#>

    /**
      * Set this function with a "function(<#=string.Join(", ", ps)#>){}" to receive the "<#= FirstCharLowered(method.Name) #>" message from the <#= hub.Name#> hub.
      * Contract Documentation: <#= docs.Summary #>
<#
    foreach (var p in method.GetParameters())
    {
#>
      * @param <#=p.Name#> {<#=GetTypeContractName(p.ParameterType)#>} <#=docs.ParameterSummary(p.Name)#>
<#
    }
#>
      * @return {void}
      */
   <#= FirstCharLowered(method.Name) #> : (<#=string.Join(", ", ps)#>) => void;
<#
    }
#>
}

<#
    }
#>
//#endregion <#= hub.Name#> hub

<#
}
#>
//#endregion service contracts



////////////////////
// Data Contracts //
////////////////////
//#region data contracts
<#
while(viewTypes.Count!=0 && false)
{
    var type = viewTypes.Pop();
#>


/**
  * Data contract for <#= type.FullName#>
  */
public class <#= GenericSpecificName(type) #> {
<#
    foreach (var property in type.GetProperties(BindingFlags.Instance|BindingFlags.Public|BindingFlags.DeclaredOnly))
    {
#>
  public <#= GetTypeContractName(property.PropertyType)#> <#= property.Name#> { get; set; }
<#
    }
#>
}
<#
}
#>

//#endregion data contracts

<#+

    private Stack<Type> viewTypes = new Stack<Type>();
    private HashSet<Type> doneTypes = new HashSet<Type>();

    private string GetTypeContractName(Type type)
    {
		
        switch (type.Name.ToLowerInvariant())
        {
		  case "datetime":
               return "DateTime";
	      case "byte":
		  return "byte";
		   case "int32":
		  case "system.int32":
		  return "int";
          //  case "int16":
         //   case "int32":
         //   case "int64":
         //   case "single":
            case "double":
                return "double";
            case "bool":
                return "bool";
            case "void":
				 return "void";
           case "string":
                return type.Name.ToLowerInvariant();
          
        }

        if (type == typeof (Task))
        {
            return "void /*task*/";
        }

        if (type.IsArray)
        {
            return GetTypeContractName(type.GetElementType())+"[]";
        }

        if (type.IsGenericType && typeof(Task<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return GetTypeContractName(type.GetGenericArguments()[0]);
        }

        if (type.IsGenericType && typeof(Nullable<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return GetTypeContractName(type.GetGenericArguments()[0]);
        }

        if (type.IsGenericType && typeof(List<>).IsAssignableFrom(type.GetGenericTypeDefinition()))
        {
            return "List<"+GetTypeContractName(type.GetGenericArguments()[0])+">";
        }

    


        if (!doneTypes.Contains(type))
        {
            doneTypes.Add(type);
            viewTypes.Push(type);
        }
        return GenericSpecificName(type);
    }

    private string GenericSpecificName(Type type)
    {
        string name = type.Name.Split('`').First();
        if (type.IsGenericType)
        {
            name += "<"+string.Join(", ", type.GenericTypeArguments.Select(GenericSpecificName))+">";
        }
        return name;
    }

    private string FirstCharLowered(string s)
    {
        return Regex.Replace(s, "^.", x => x.Value.ToLowerInvariant());
    }

    Dictionary<Assembly, XDocument> xmlDocs = new Dictionary<Assembly, XDocument>(); 

    private XDocument XmlDocForAssembly(Assembly a)
    {
        XDocument value;
        if (!xmlDocs.TryGetValue(a, out value))
        {
            var path = new Uri(a.CodeBase.Replace(".dll", ".xml")).LocalPath;
            xmlDocs[a] = value = File.Exists(path) ? XDocument.Load(path) : null;
        }
        return value;
    }

    private MethodDocs GetXmlDocForMethod(MethodInfo method)
    {
        var xmlDocForHub = XmlDocForAssembly(method.DeclaringType.Assembly);
        if (xmlDocForHub == null)
        {
            return new MethodDocs();
        }

        var methodName = string.Format("M:{0}.{1}({2})", method.DeclaringType.FullName, method.Name, string.Join(",", method.GetParameters().Select(x => x.ParameterType.FullName)));
        var xElement = xmlDocForHub.Descendants("member").SingleOrDefault(x => (string) x.Attribute("name") == methodName);
        return xElement==null?new MethodDocs():new MethodDocs(xElement);
    }

	private Type ClientType(Type hubType)
	{
		while (hubType != null && hubType != typeof(Hub))
		{
			if (hubType.IsGenericType && hubType.GetGenericTypeDefinition() == typeof (Hub<>))
			{
				return hubType.GetGenericArguments().Single();
			}
			hubType = hubType.BaseType;
		}
		return null;
	}

    private class MethodDocs
    {
        public MethodDocs()
        {
            Summary = "---";
            Parameters = new Dictionary<string, string>();
        }

        public MethodDocs(XElement xElement)
        {
            Summary = ((string) xElement.Element("summary") ?? "").Trim();
            Parameters = xElement.Elements("param").ToDictionary(x => (string) x.Attribute("name"), x=>x.Value);
        }

        public string Summary { get; set; }
        public Dictionary<string, string> Parameters { get; set; }
    
        public string ParameterSummary(string name)
        {
            if (Parameters.ContainsKey(name))
            {
                return Parameters[name];
            }
            return "";
        }
    }

#>